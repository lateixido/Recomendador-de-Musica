# -*- coding: utf-8 -*-
"""train_model.ipynb
Automatically generated by Colab.
"""

# Importamos librer√≠as necesarias
import pandas as pd           # Manejo de datasets en formato tabular
import numpy as np            # Operaciones num√©ricas
import joblib                 # Guardado y carga de modelos entrenados
from sklearn.preprocessing import MultiLabelBinarizer, StandardScaler  # Preprocesamiento
from sklearn.neighbors import NearestNeighbors                         # Algoritmo KNN
from scipy.sparse import hstack, csr_matrix                            # Manejo de matrices dispersas

# --- 1) Cargar dataset ---
df = pd.read_csv("~/Developer/Diplomado UADE/Recomendador de discos/model_python/light_spotify_dataset.csv")

# Definimos las columnas necesarias
needed_cols = ["song", "artist", "Danceability", "Energy", "Positiveness", "Loudness"]
# Verificamos si faltan columnas esperadas
missing = [c for c in needed_cols if c not in df.columns]
if missing:
    raise ValueError(f"Missing expected columns: {missing}")

# Eliminamos registros con valores nulos en las columnas clave
df = df.dropna(subset=needed_cols).reset_index(drop=True)

# --- 2) Preparar features ---
# Extraemos las features num√©ricas para el modelo
num_features = df[["Danceability", "Energy", "Positiveness", "Loudness"]].to_numpy(dtype=float)

# Escalamos las features num√©ricas con StandardScaler
scaler = StandardScaler()
num_scaled = scaler.fit_transform(num_features)
X = csr_matrix(num_scaled)  # Convertimos a matriz dispersa

# --- 3) Entrenar modelo NearestNeighbors ---
best_params = {"n_neighbors": 10, "metric": "cosine", "algorithm": "brute"}
knn = NearestNeighbors(**best_params)
knn.fit(X)

# Comentario sobre hiperpar√°metros:
# - n_neighbors = 10 ‚Üí cantidad de recomendaciones
# - metric = cosine ‚Üí similaridad angular entre vectores
# - algorithm = brute ‚Üí recomendado con pocas features y m√©trica cosine

# --- 4) Construir vector de features para una canci√≥n ---
def build_feature_vector(row_idx: int):
    row = df.loc[row_idx, ["Danceability", "Energy", "Positiveness", "Loudness"]].to_numpy(dtype=float).reshape(1, -1)
    e_scaled = scaler.transform(row)       # Escalamos igual que el dataset
    return csr_matrix(e_scaled)            # Retornamos en formato disperso

# --- 5) Buscar √≠ndice de una canci√≥n ---
def get_track_index(track: str, artist: str | None = None) -> int:
    name_mask = df["song"].str.casefold().str.strip() == track.casefold().strip()
    if not name_mask.any():
        raise ValueError(f"Track '{track}' not found.")

    # Si se pasa artista, filtramos a√∫n m√°s
    if artist is not None and "artist" in df.columns:
        artist_mask = df["artist"].str.casefold().str.strip() == artist.casefold().strip()
        mask = name_mask & artist_mask
        if not mask.any():
            options = df.loc[name_mask, "artist"].dropna().unique().tolist()
            raise ValueError(f"No match for '{track}' by '{artist}'. "
                             f"Available artists for that title: {options}")
        idxs = df.index[mask].tolist()
    else:
        idxs = df.index[name_mask].tolist()
        if len(idxs) > 1:  # T√≠tulo ambiguo
            options = df.loc[idxs, "artist"].dropna().unique().tolist()
            raise ValueError(f"Ambiguous track title '{track}'. Please specify artist. "
                             f"Options: {options}")

    return idxs[0]

# --- 6) Funci√≥n principal de recomendaci√≥n ---
def recommend_by_track_name(track: str, top_k: int = 10, artist: str | None = None):
    idx = get_track_index(track, artist)
    q = build_feature_vector(idx)

    distances, indices = knn.kneighbors(q, n_neighbors=top_k + 1)
    recs = []
    for d, i in zip(distances[0], indices[0]):
        if i == idx:  # saltamos la canci√≥n semilla
            continue
        recs.append({
            "song": df.loc[i, "song"],
            "artist": df.loc[i, "artist"],
            "Danceability": df.loc[i, "Danceability"],
            "Energy": df.loc[i, "Energy"],
            "Positiveness": df.loc[i, "Positiveness"],
            "Loudness": df.loc[i, "Loudness"],
            "distance": float(d)
        })
        if len(recs) == top_k:
            break
    return recs

# --- 7) Guardar artefactos entrenados ---
artifacts = {
    "knn_model": knn,
    "scaler": scaler,
    "best_params": best_params,
    "feature_matrix_shape": X.shape,
    "track_index": df[needed_cols],
}
joblib.dump(artifacts, "music_recommender_numeric_small.joblib")
print("üíæ Saved: music_recommender_numeric_small.joblib")

# --- 8) Prueba r√°pida (smoke test) ---
try:
    user_track = input("Enter a track name: ").strip()
    user_artist = None

    try:
        recs = recommend_by_track_name(user_track, top_k=10)
        print(f"\nRecommendations for: {user_track}\n")
    except ValueError as amb:
        text = str(amb)
        if "Please specify artist" in text:
            print(text)
            user_artist = input("Enter the artist to disambiguate: ").strip()
            recs = recommend_by_track_name(user_track, top_k=10, artist=user_artist)
            print(f"\nRecommendations for: {user_track} | {user_artist}\n")
        else:
            raise

    for r in recs:
        print(f"  - {r['song']} | {r['artist']} | "
              f"Danceability={r['Danceability']} | Energy={r['Energy']} | "
              f"Positiveness={r['Positiveness']} | Loudness={r['Loudness']} | "
              f"dist={r['distance']:.3f}")

except Exception as e:
    print("Smoke test skipped:", e)

# --- 9) Ejemplo fijo con 'Rick Astley - Dance' ---
track = "Dance"
artist = "Rick Astley"

idx = get_track_index(track, artist)
q = build_feature_vector(idx)

k = 10
distances, indices = knn.kneighbors(q, n_neighbors=k + 1)

seen = set()
count = 0
for d, i in zip(distances[0], indices[0]):
    if i == idx:
        continue  # saltamos semilla

    sim = max(0.0, min(1.0, 1.0 - float(d)))  # Similaridad derivada de la distancia coseno

    key = (df.at[i, "song"], df.at[i, "artist"])
    if key in seen:
        continue
    seen.add(key)

    song = df.at[i, "song"]
    art  = df.at[i, "artist"]
    print(f"{song} | {art} | dist={d:.8f} | sim={sim:.4f}")

    count += 1
    if count == k:
        break